------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ITERATOR

Iterators in Python are objects that allow you to traverse through a sequence of elements one at a time, without needing to know the underlying structure of the sequence.
They are used to iterate over collections like lists, tuples, dictionaries, and sets. Hereâ€™s a breakdown of how they work:

Iterator Protocol: An object is considered an iterator if it implements two methods:

__iter__(): Returns the iterator object itself. This method is required for the object to be used in a for loop or other iteration contexts.
__next__(): Returns the next item in the sequence. When there are no more items to return, it raises the StopIteration exception to signal the end of the iteration.
python
Copy code
class MyIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.end:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1

it = MyIterator(1, 4)
for num in it:
    print(num)  # Outputs: 1, 2, 3
Iterable Objects: An object is considered iterable if it implements the __iter__() method, which should return an iterator. 
Iterable objects include lists, tuples, strings, and dictionaries. These objects can be used directly in a for loop or with functions like map(), filter(), and zip().
my_list = [1, 2, 3]
it = iter(my_list)  # Convert list to an iterator
print(next(it))  # Outputs: 1
print(next(it))
print(next(it))
HERE if we still add one more next statement itw ill give you stopiteration errror
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GENERATORS

Generators in Python are a powerful feature for creating iterators in a simpler and more concise way. They allow you to iterate over sequences of values without needing to store the entire sequence in memory,
Generators are a type of iterable, like lists or tuples, but they generate items one at a time and only as needed

Sfter return, code is  inreacheable, but for yield its not like that, even after yield you can still do another yild.

ITERATOR IS A CLASS, GENEARTOR IS FUNCTIOn

def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # Outputs: 1
print(next(gen))  # Outputs: 2
print(next(gen))  # Outputs: 3

How Generators Work
State Preservation: Generators maintain their state between yield calls. This means they remember where they left off.Lazy Evaluation: Generators evaluate values only when needed.

def gen(start,end):
    while start<=end:
        yield start
        start+=1

for i in gen(4,8):
    print(i)
or

def gen(start,end):
    while start<=end:
        yield start
        start+=1

out=gen(4,8)
print(next(out))
print(next(out))
print(next(out))
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Can you give an example where using an iterator is preferable to using a list?
Example: Reading Large Files

When dealing with large files, loading the entire file into memory might be impractical due to memory constraints. Using an iterator allows you to process the file line by line without loading the entire file into memory.

4. What happens if you use yield inside a function without __iter__() and __next__() methods?
Example: Using yield in a Generator Function

python
Copy code
def simple_gen():
    yield 1
    yield 2
    yield 3

# Usage
gen = simple_gen()
for value in gen:
    print(value)

Example 3: Using send() to Control Generator Execution
This example shows how to use send() to control the flow of execution in a generator.

python
Copy code
def controlled_counter():
    count = 0
    while True:
        count = yield count
        if count is None:
            count = 0
        print(f"Count is now: {count}")

# Usage
gen = controlled_counter()
next(gen)  # Prime the generator
print(gen.send(5))  # Outputs: Count is now: 5
print(gen.send(10))  # Outputs: Count is now: 10
print(gen.send(None))  # Outputs: Count is now: 0

Python have many builtin functions like len, type, sorted, any, all, bin, zip, enumerate

The general structure of a nested list comprehension is:

[expression for item in iterable1 for item in iterable2]

matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

flattened = [element for row in matrix for element in row]
print(flattened)
# Outputs: [1, 2, 3, 4, 5, 6, 7, 8, 9]

to flatten long nexted sublits
def flatten(nested_list):
    flat_list = []
    
    for element in nested_list:
        if isinstance(element, list):
            flat_list.extend(flatten(element))  # Recursively flatten sublists
        else:
            flat_list.append(element)
    
    return flat_list

# Example usage
nested_list = [1, 3, [2, 4, 5, [4, 5, [6, 7, 8, [7, 7, [5, 5, 5, 5, 5, [6, 6, 6]], 7, 78], 67788], 7, 8, 9], 6, 7, 8, 8, 9, 9, 9999], 7, 7, 7]
flattened_list = flatten(nested_list)
print(flattened_list)

----------------------------------------------------------
ZIP

names = ['Alice', 'Bob', 'Charlie']
scores = [85, 90, 78]

combined = list(zip(names, scores))
print(combined)
output is [('Alice', 85), ('Bob', 90), ('Charlie', 78)]

if you use just (zip(names, scores)), output will be an object like below
<zip object at 0x000002D9E3675180>
-------------------------------------------------------------------
dictionary copreghenion
Remember dictionary comprehension will have { symbol list comprehension have [

keys=["aaa","bbbb","ccc"]
values=[1,2,3]

out={key:value for key,value in zip(keys,values)}
print(out)

tABLE WITH DICT COMPREHENSION

out={y: x*y for x in range(1,6) for y in range(1,6)}
print(out)
out={1: 5, 2: 10, 3: 15, 4: 20, 5: 25}


out={y: [x*y for x in range(1,6)] for y in range(1,6)}
print(out)
out={1: [1, 2, 3, 4, 5], 2: [2, 4, 6, 8, 10], 3: [3, 6, 9, 12, 15], 4: [4, 8, 12, 16, 20], 5: [5, 10, 15, 20, 25]}

---------------------------------------------------------
Fibo using iterator
class Fibo:
    def __init__(self):
        self.a = 0
        self.b = 1

    def __iter__(self):
        return self  # Return the iterator object itself

    def __next__(self):
        if self.a > 10:
            raise StopIteration  # Stop iteration if the condition is met
        else:
            temp = self.a
            self.a, self.b = self.b, self.a + self.b
            return temp

# Create an instance of Fibo
obj = Fibo()

# Use the created instance to iterate
for i in obj:
    print(i)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. What is a Decorator?
A decorator is a function that takes another function (or method) as an argument and returns a new function that typically extends or alters the behavior of the original function. Decorators are commonly used for logging, access control, memoization, and more.

def to_uppercase_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()

    return wrapper

@to_uppercase_decorator
def get_result():
    return "hello world"

print(get_result())  # Outputs: HELLO WORLD
--------------------------------------------------------------------------
applying 2 decoratoes on single func, here inner mostw ill be considered first which converts to upper then spliwords is considered.

def to_uppercase_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

def split_words_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.split()

    return wrapper


@split_words_decorator
@to_uppercase_decorator
def get_result():
    return "hello world python decorators"

print(get_result())  # Outputs: ['HELLO', 'WORLD', 'PYTHON', 'DECORATORS']

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

o pass parameters to a decorator function, you need to create a decorator factory. A decorator factory is a function that returns a decorator

def to_case_decorator(name):
    def decorator(func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            return result.upper() +name
        return wrapper
    return decorator



@to_case_decorator(" LAKSHMI")
def get_result():
    return "hello world python decorators"

print(get_result())  # Outputs: ['HELLO', 'WORLD', 'PYTHON', 'DECORATORS']
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Decorators can be implemented with functions also an dmethods also which is with classes\

A way to pass argumnets is below

def repeat(times):
    def decorator(func):
        def wrapper():
            result=func()
            for i in range(times):
                return result*times
        return wrapper
    return decorator

@repeat(5)
def message():
    return "hello, Welcome!!!"

print(message())

or below
def repeat():
    def decorator(func):
        def wrapper(times):
            result=func()
            for i in range(times):
                return result*times
        return wrapper
    return decorator

@repeat()
def message():
    return "hello, Welcome!!!"

print(message(5))
---------------------------------------------------------------------------------------
Example: Authorization Check

python
Copy code
def require_admin(func):
    def wrapper(user_role, *args, **kwargs):
        if user_role != "admin":
            return "Access denied"
        return func(*args, **kwargs)
    return wrapper

@require_admin
def admin_task():
    return "Admin task performed"

print(admin_task("user"))  # Outputs: Access denied
print(admin_task("admin"))  # Outputs: Admin task performed
---------------------------------------------------------------------------------------
Class based decorators, builtin decorators, decorartors for methods

class abse ddecorators
class RepeatDecorator:
    def __init__(self, times):
        self.times = times

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            return result * self.times
        return wrapper

@RepeatDecorator(times=3)
def greet():
    return "Hello! "

print(greet())

or withput init below
class RepeatDecorator:
    def __call__(self, func):
        def wrapper(times,*args, **kwargs):
            result = func(*args, **kwargs)
            return result * times
        return wrapper

@RepeatDecorator()
def greet():
    return "Hello! "

print(greet(3))
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

below is class based decorator
call is special method for printigd ata in it


class Mydecorator:
    def __init__(self):
        pass
    def __call__(self,func):
        def wrapper(*args, **kwargs):
            result=func(*args, **kwargs)
            return result.upper()
        return wrapper


class Myclass:
    def __init__(self):
        pass
    @Mydecorator()
    def main(self):
        return "Hello, Welcome!!!"
    
out=Myclass()
print(out.main())
------------------------------------------------------------------------------


If you dont wnat to use call method in decorator clases, calling should be different like below

class Mydecorator:
    def __init__(self):
        pass
    def decorator(self,func):
        def wrapper(*args, **kwargs):
            result=func(*args, **kwargs)
            return result.upper()
        return wrapper


class Myclass:
    def __init__(self):
        pass
    @Mydecorator().decorator
    def main(self):
        return "Hello, Welcome!!!"
    
out=Myclass()
print(out.main())

 @Mydecorator().decorator is change we saw above

-----------------------------------------------------------------------------------------------
decorators for methods

def mydecorator(method):
    def wrapper(self,*args,**kwargs):
        if self.name=="Lucky":
            print ("Yess, correct")
        else:
            return method(self,*args,**kwargs)  
    return wrapper



class Myclass:
    def __init__(self,name):
        self.name=name
    @mydecorator
    def main(self):
        return f"Hey {self.name}"
    
obk1=Myclass("Ammu")
print(obk1.main())

-----------------------------------------------------------------------------------------------
typles of namespaces
global,local,builtin
global when we do imports, local for function and classes , builtin when you write python code

variable: part of program where variable is accessible called a svariable scope

local scope: names inside function
global scope:names at top of scipt, available throught program
enclosed scope: names in enclosed function, eg: nested functions
builtin scope: names builtin to python ..eg: print, any, all,zip,enumerate
LEGB rule
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
